#
def bisection_method(f, a, b, tol=1e-6, max_iter=100):
    """
    Find a root of the function f using the bisection method.
    
    f: Function
    a (float): The lower bound of the interval.
    b (float): The upper bound of the interval.
    tol (float): The tolerance for stopping condition.
    max_iter (int): Maximum number of iterations.

    Returns:
    float: Approximate root of the function.

    Raises:
    ValueError: If f(a) and f(b) do not have opposite signs.
    ValueError: If a and b are the same.
    ValueError: If no root is found within max_iter iterations.
    """

    # Validate input
    if a == b:
        raise ValueError("Interval bounds 'a' and 'b' must be different.")
    
    fa, fb = f(a), f(b)
    
    if fa * fb > 0:
        raise ValueError("Function values at a and b must have opposite signs.")

    # Bisection method iterations
    for _ in range(max_iter):
        c = (a + b) / 2  
        fc = f(c)

        if abs(fc) < tol:
            return c
        
        # Narrow the interval
        if fa * fc < 0:
            b, fb = c, fc
        else:
            a, fa = c, fc

    raise ValueError("Root not found within the maximum number of iterations.")

def test_bisection_method():

    # Test 1: Root of x^2 - 4 in [0,5] should be ~2
    f1 = lambda x: x**2 - 4
    root1 = bisection_method(f1, 0, 5, tol=1e-6)
    assert abs(root1 - 2) < 1e-6, "Test 1 failed"
    print("Test 1 passed")

    # Test 2: Root of x^3 - 6x^2 + 11x - 6 in [0, 2.5]
    f = lambda x: x**3 - 6*x**2 + 11*x - 6  # Roots at x=1,2,3
    root = bisection_method(f, 1.5, 2.5, tol=1e-6)
    assert abs(root - 2) < 1e-6, "Test 2 failed"
    print("Test 2 passed")

    # Test 3: No root in the interval [-2, 2] for x^2 + 1
    f3 = lambda x: x**2 + 1  # No real root
    try:
        bisection_method(f3, -2, 2)
        assert False, "Test 3 failed (Expected ValueError)"
    except ValueError:
        print("Test 3 passed")

    # Test 4: Invalid interval (a == b)
    try:
        bisection_method(f1, 3, 3)
        assert False, "Test 4 failed (Expected ValueError)"
    except ValueError:
        print("Test 4 passed")

    # Test 5: f(a) and f(b) have same signs
    try:
        bisection_method(f1, 3, 5)  # f(3) and f(5) are both positive
        assert False, "Test 5 failed (Expected ValueError)"
    except ValueError:
        print("Test 5 passed")

    print("All tests passed")

# Run tests
if __name__ == "__main__":
    test_bisection_method()
